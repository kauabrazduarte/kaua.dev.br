<style>
    #webgl-canvas {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: -1;
        outline: none;
    }
</style>

<script>
    import * as THREE from "three";
    import { GLTFLoader } from "three/examples/jsm/loaders/GLTFLoader.js";

    const scene = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000,
    );

    camera.position.z = 6;

    const renderer = new THREE.WebGLRenderer({
        antialias: true,
    });

    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);

    renderer.domElement.id = "webgl-canvas";
    document.body.appendChild(renderer.domElement);

    const ambientLight = new THREE.AmbientLight(0xffffff, 1);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 2);
    directionalLight.position.set(5, 10, 7.5);
    scene.add(directionalLight);

    const loader = new GLTFLoader();
    let model;

    loader.load(
        "/model/scene.gltf",
        (gltf) => {
            model = gltf.scene;
            model.scale.set(1, 1, 1);
            const box = new THREE.Box3().setFromObject(model);
            const center = box.getCenter(new THREE.Vector3());
            model.position.sub(center);

            scene.add(model);

            animate();
        },
        undefined,
        (error) => {
            console.error("Erro ao carregar:", error);
        },
    );

    let mouseX = 0;
    let mouseY = 0;

    let isMobile = window.innerWidth < 768;

    window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);

        isMobile = window.innerWidth < 768;
    });

    document.addEventListener("mousemove", (e) => {
        if (!isMobile) {
            mouseX = (e.clientX - window.innerWidth / 2) * 0.001;
            mouseY = (e.clientY - window.innerHeight / 2) * 0.001;
        }
    });

    let isDragging = false;
    let previousTouchX = 0;
    let previousTouchY = 0;

    const touchSensitivity = 0.005;
    const autoRotateSpeed = 0.01;

    document.addEventListener("touchstart", (e) => {
        if (isMobile) {
            isDragging = true;
            previousTouchX = e.touches[0].clientX;
            previousTouchY = e.touches[0].clientY;
        }
    });

    document.addEventListener("touchmove", (e) => {
        if (isMobile && isDragging && model) {
            const currentTouchX = e.touches[0].clientX;
            const currentTouchY = e.touches[0].clientY;
            const deltaX = currentTouchX - previousTouchX;
            const deltaY = currentTouchY - previousTouchY;

            model.rotation.y += deltaX * touchSensitivity;
            model.rotation.x += deltaY * touchSensitivity;

            previousTouchX = currentTouchX;
            previousTouchY = currentTouchY;
        }
    });

    document.addEventListener("touchend", () => {
        isDragging = false;
    });

    function animate() {
        requestAnimationFrame(animate);

        if (model) {
            if (isMobile) {
                if (!isDragging) {
                    model.rotation.y += autoRotateSpeed;
                }
            } else {
                model.rotation.y += 0.005;
                model.rotation.x += (mouseY - model.rotation.x) * 0.1;
                model.rotation.y += (mouseX - model.rotation.y) * 0.1;
            }
        }

        renderer.render(scene, camera);
    }
</script>
